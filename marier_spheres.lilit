# Background

In sound design, digital musical instrument design, and intermedia art in
general, creators often deal with complex generative systems with numerous
control parameters: sound and video synthesizers and processors, simulations,
and artificially intelligent agents to name just a few. These systems are often
capable of producing a combinatorially immense variety of interesting behaviors
(sounds, images, etc.) based on the state of their parameters. Much of the
creative work of using and interacting with these systems often comes down to
simply exploring these vast spaces of possibilities, perhaps noting points of
interest along the way. Eventually, entire compositions, installations, or
musical instruments can be devised by selecting the most meaningful or
appropriate paths to navigate within these spaces of possibilities.

A useful tool in the exploration and navigation of these spaces is preset
interpolation. After manually recording the points of interest as presets,
preset interpolation algorithms are used to automatically move between these
predetermined a-priori interesting places, filling in the space between them
with intermediate locations that are likely, by proximity, to also be
interesting. This allows the user of a preset interpolation algorithm to move
easily through the space of possibilities demarcated by the points of interest
they record as presets, facilitating the discovery of other interesting points
in space and of interesting paths through space.

What is especially useful about preset interpolation is that it allows the user
to reframe the navigation of the control parameter space in terms of another
separate space of control sources. For instance, the presets in parameter space
can be associated with locations on a two dimensional map, often significantly
reducing the dimensionality of navigation with an associated reduction in the
difficulty of navigation. Alternatively, the control sources from a complex
gestural interface can be used instead of a two dimensional map, allowing the
destination space to be navigated by moving through the space of gestures
afforded by the interface. These kinds of mappings are often essential in the
design of digital musical instruments, and can be equally rewarding in other
intermedia artistic practices.

The basic operating principle of many preset interpolation algorithms,
including the one presented here, is for the user to specify pairs of
source-to-destination associations in the form of presets in these two spaces.
As a concrete example, the user might be exploring the space of sounds produced
by a synthesizer with possibly a very large number of parameters. They might
explore for a while by manually configuring the synthesizer, and note several
particularly interesting preset sound configurations. Then, to facilitate live
performance with the synthesizer, the user may wish to control it with a
graphics tablet. They can associate several locations on the tablet with
different presets found earlier, and then use the preset interpolation
algorithm to navigate between these presets. The tablet locations can also be
thought of as presets in the source space rather than the destination space of
the sound synthesizer.

To remain unambiguous, for the rest of this exposition preset points in source
space will be refered to as source vectors while preset points in destination
space will be referred to as destination vectors. The word vector reflects the
assumption inherent in most preset interpolation algorithms that the source and
destination spaces are both vector spaces, meaning that presets can be
meaningfully scaled and added together, and that there is a meaningful notion
of distance between presets.  A pair made of a source vector $s$ and a
destination vector $p$ to which the sources in the vicinity of $s$ should be
associated will be called a demonstration. This reflects an interaction
metaphor in which the user is thought to provide demonstrations of
action-to-output relationships, i.e. "when I do $s$, the interpolator should
output $p$."

The basic principle of many interpolation algorithms is to interpolate between
destination vectors producing an output parameter vector $y$ via a weighted
sum.

y(\bm{w}) = \sum_{i = 0}^{n - 1} w_i * p_i

Where $n$ is the number of demonstrations (i.e. the size of the set $D$ of
demonstrations). The role of the preset interpolator is then reduced to simply
producing and applying a list of weights, usually as a function of a query or
cursor vector $q$ in the source space, and the list of demonstrations.

\bm{w}(q, D) = {w_0, w_1, w_2, ..., w_{n}}
D = { {s_0, p_0}, {s_1, p_1}, {s_2, p_2}, ..., {s_n, p_n} }

# Intersecting N-Spheres Interpolation

Martin Marier introduced the *intersecting n-spheres interpolation* algorithm
as part of his work with The Sponge, a deformable digital musical instrument
which Marier has been developing for over a decade. This algorithm produces an
interpolated output that is smooth (i.e. continuously differentiable),
continuous, maps from any number of source dimensions to any number of
destination dimensions, exactly passes through the demonstrated destination points,
and locally depends only on nearby demonstrations. The algorithm also
imposes no constraints on the placement of source and destination presets, unlike
other algorithms which might require points to be evenly distributed or
quantized to a grid. Furthermore, the algorithm allows for the position of
presets to be dynamically varied in real-time, allowing the possibility for
higher-level mappings such as navigating destination presets for the preset
interpolation system itself using a higher-level preset interpolator. 

Intersecting n-spheres interpolation produces weights for a weighted sum
according to the following procedure:

1. For every point in source space including the cursor point, determine the
distance ($R$ for the cursor point, $r_i$ for the demonstrated source points)
from that point to its nearest neighbour in source space. Consider the
distances $R$ and $r_i$ as the radii of circles centered on their respective
points.

2. Determine the distance $d_i$ from each demonstrated source point $s_i$ to
the cursor point.

3. The weight $w_i$ associated with the destination vector $p_i$ of the $i$th
demonstration is given by the $A_x(R, r_i, d_i) / A(r_i)$ where $A_x$ is the
area of the intersection of the circles defined by $R$, $r_i$, and their
respective data points as though the circles lay on a plane passing through
both points, and $A$ is the area of the circle defined by $r_i$ and its point.
$A_x$ is given by the following function, which depends only on the radii of
the two circles and the distance between them:

A_x(R, r, d) &= r^2 cos^(-1) \( \frac{d^2 + r^2 - R^2}{2dr} \)
             &+ R^2 cos^(-1) \( \frac{d^2 + R^2 - r^2}{2dR} \)
             &- \frac{\sqrt{(-d + r + R)(d + r - R)(d - r + R)(d + r + R)}}{2}

4. Normalize the weights so that their sum is equal to one.

The algorithm, despite its name, actually doesn't utilized hyperspheres.
Intead, 2D areas are used, simplifying the algorithm while producing results
that "are predictable and feel natural to the user" according to Marier.

# Implementation

The weighted sum in Marier's algorithm implies that the destination space is
some kind of vector space, while the requirement for a notion of distance
implies that the source space is a normed vector space, most often an Euclidean
vector space. These assumptions are represented in the implementation by the
assumption that the templated PVector for the destination space will have an
operator for multiplication by a scalar, and addition of two vectors, and that
the templated SVector for the source space will have the same two operators as
well as a method `norm` that returns the length of a vector.

The functions to compute the weight for a single destination vector are
generally straightforward to implement based on the equations in step 3 above.

One necessary quirk: when the interpolator is used with `float` scalars, the
argument to the `acos` and `sqrt` calls sometimes falls just outside the domain
of the functions. Boundary conditions are checked if `Scalar` is `float`: in
testing, the `acos` args only ever fell at or slightly above `1.0f`, so this
is the only condition which is addressed by the boundary check for these args.

@='weight functions'
template<typename Scalar>
Scalar circle_circle_intersection_area(
        const Scalar& R, 
        const Scalar& r, 
        const Scalar& d)
{
    Scalar d2 = d * d;
    Scalar r2 = r * r;
    Scalar R2 = R * R;
    Scalar two_d = (Scalar)2 * d;
    Scalar arg1 = (d2 + r2 - R2)/(two_d * r);
    Scalar arg2 = (d2 + R2 - r2)/(two_d * R);
    Scalar arg3 = (-d+r+ R) * (d+r-R) * (d-r+R) * (d+r+R);
    Scalar a, b, c;
    if constexpr (std::is_same_v<Scalar, float>)
    {
        if (arg1 > 1.0f) a = 0;
        else a = r2 * std::acos(arg1);
        if (arg2 > 1.0f) b = 0;
        else b = R2 * std::acos(arg2);
        if (arg3 < 0.0f) c = 0;
        else c = std::sqrt(arg3) / 2.0f;
    }
    else
    {
        a = r2 * std::acos(arg1);
        b = R2 * std::acos(arg2);
        c = std::sqrt(arg3) / (Scalar)2.0;
    }
    return a + b - c;
}

template<typename Scalar>
Scalar circle_area(const Scalar& r)
{
    constexpr Scalar pi = 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899863;
    return pi * r * r;
}

template<typename Scalar>
Scalar marier_spheres_weight(const Scalar& R, const Scalar& r, const Scalar& d)
{
    return circle_circle_intersection_area(R, r, d) / circle_area(r);
}
@

Step 1 above is an instance of the "all nearest neighbours" problem. We are
given a set of points (the demonstrated points in the source space plus the
cursor point) and for each point $p$ we need to determine the nearest other
point in the space $p_{\text{nearest}}$, which will be used to determine the
radius of the circle associated with $p$.

Efficient algorithms exist which solve the all nearest neighbours problem in
$O(n\log n)$ time, or even in $O(n)$ time if certain constraints are met, which
is most likely the case for this application. Unfortunately, comprehending (let
alone implementing) the linear time algorithms for this problem is non-trivial,
so we opt to use a simpler algorithm until such time as it becomes clear that
optimization is necessary.

Updating any of the points in source space including the cursor point always
requires the nearest neighbour problem to be solved anew, because the nearest
neighbour of the updated point and any point that it was previously the nearest
neighbour of all have to be updated. Because the position of the cursor point
is assumed to change whenever the interpolator is queried, this means that the
nearest neighbour problem must be solved for every query. The trivial
implementation used here (as well as in Marier's original presentation of the
interpolation algorithm) solves this problem with $O(n^2)$ time complexity. In
Marier's practice this hasn't been reported as an issue, presumably because the
number of data points has always been reasonably low.

Because the all nearest neighbours problem has to be solved for every query,
there is no need for a special data structure to hold the demonstrations. The
query function could be written as a generic pure function over the query point
and the list of demonstrations. However, for interactive applications it is
likely to be useful for the caller to query the radii and weights associated
with each demonstration, so room for these is included in the data structure
for holding a demonstration.

@='intersecting n-spheres'
template<typename Scalar, typename ID, typename SVector, typename PVector>
class MarierSpheresInterpolator
{
public:
    struct Demo { ID id; SVector s; PVector p; Scalar r, d, w;};
    Scalar q_radius;

    template<typename DemoList>
    PVector query(const SVector& q, DemoList& demos)
    {
        Scalar sum_of_weights = 0;
        PVector weighted_sum = PVector() * 0;
        if (demos.size() < 1) return weighted_sum;

        @{find q_radius}

        for (auto& demo : demos)
        {
            @{calculate distance}
        
            @{find radius}
        
            if ((q_radius + demo.r) < demo.d) 
            {
                demo.w = 0;
                continue; // the circles are non-intersecting
            }
            demo.w = marier_spheres_weight(q_radius, demo.r, demo.d);
            sum_of_weights = sum_of_weights + demo.w;
            weighted_sum = weighted_sum + demo.w * demo.p;
        }
        weighted_sum = (1 / sum_of_weights) * weighted_sum;
        for (auto& demo : demos) { demo.w = demo.w / sum_of_weights; }
        return weighted_sum;
    }
};
@

The radius associated with the query point (and indeed every point) is searched
for by brute force. Although far from optimal, this implementation seems good
enough for now.

Although every demonstration will be visited in the main loop of the query
function, the radius of the query point has to be known in advance in order
to calculate the weight associated with each point.

@='find q_radius'
q_radius = std::numeric_limits<Scalar>::max();
for (const auto& demo : demos)
{
    Scalar d = (demo.s - q).norm();
    if (d < q_radius) q_radius = d;
}
@

If the query is close enough to the demonstration, the exact value of the
demonstration is returned and further calculation of the weighted sum is
short-circuited.  As the query point approaches the position of a demonstrated
point, the size of both $A_x$ and $A$ get smaller and smaller, which would
likely lead to numerical instability when calculating the weight $A_x/A$. For
this reason, an arbitrary amount of sloppiness is introduced into the
determination of whether the query point exactly coincides with a demonstrated
point, so that the ratio $A_x/A$ will not be calculated if the query is too
close to a demonstration.

@='calculate distance'
demo.d = (demo.s - q).norm();
constexpr Scalar an_arbitrary_slop_factor = 
    std::numeric_limits<Scalar>::epsilon() * 5;
if (demo.d <= an_arbitrary_slop_factor) return demo.p;
@

@='find radius'
demo.r = std::numeric_limits<Scalar>::max();
for (const auto& demo2 : demos)
{
    if (demo.id == demo2.id) continue;
    Scalar d = (demo.s - demo2.s).norm();
    if (d < demo.r) demo.r = d;
}
if (demo.d < demo.r) demo.r = demo.d;
@

Putting it all together, we get a reasonably generic header-only library
implementing Marier's algorithm.

@#'interpolator/marier_spheres.h'
#ifndef MARIER_SPHERES_INTERPOLATOR_H
#define MARIER_SPHERES_INTERPOLATOR_H
#include<limits>
#include<cmath>
#include<iostream>

@{weight functions}

@{intersecting n-spheres}
#endif
@

# Usage

The remainder of this document elaborates some example programs demonstrating
the usage of the library. The drawing example renders an image based on
interpolating randomly generated colors associated with randomly generated 2D
positions. The interactive example works similarly, only instead of
systematically querying the image the user moves a cursor around it to query
the interpolated colors, and the graphics are updated in real time to reflect
the underlying state of the interpolator.

## Drawing example

This simple command line drawing application will randomly generate a handful
of source-destination demonstrations, and draw an image by systematically
querying the source space. As well as producing an image that might offer some
intuition about the topology of the interpolated output, this will also serve
as a reasonable benchmark for the efficiency of the implementation if the
number of pixels in the image is large enough.  The initial implementation of
the interpolator could process about 250 queries per second with 5
demonstrations, but only about 40 per second with 15 demonstrations, reflecting
the poor time complexity of the initial implementation.

The user will have to ensure that Eigen is available on their system to compile
this example; the other dependencies are included in the repository as
subtrees and should be available automatically.

Here's the overview of the example source code:

@='basic globals'
using Scalar = float;
using ID = unsigned int;
using Vec2 = Eigen::Vector2f;
using RGBVec = Eigen::Vector3f;
using Interpolator = MarierSpheresInterpolator<Scalar, ID, Vec2, RGBVec>;
using Demo = typename Interpolator::Demo;

Interpolator interpolator;
std::vector<Demo> demos;
@

@#'examples/color_image.cpp'
#include <cmath>
#include <random>
#include <chrono>
#include <iostream>
#include <vector>
#include "include/fire-hpp/fire.hpp"
#include "include/bitmap/bitmap_image.hpp"
#include "../interpolator/marier_spheres.h"
#include <Eigen/Core>

@{basic globals}

int fired_main(
        unsigned int x = fire::arg("x", "The horizontal dimension in pixels", 500), 
        unsigned int y = fire::arg("y", "The vertical dimension in pixels", 500), 
        unsigned int n = fire::arg("n", "The number of demonstrations", 5))
{
    bitmap_image img(x, y); 
    img.clear();

    @{generate random demonstrations}

    auto start = std::chrono::high_resolution_clock::now();

    @{draw the image}

    auto stop = std::chrono::high_resolution_clock::now();
    auto usec = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();
    std::cout << "Generated " << x * y << " interpolations in " << usec << " microseconds\n" 
            << "About " << 1000000 * x * y / usec << " interpolations per second" 
            << std::endl;

    @{draw circles over demonstrated points}

    img.save_image("interpolated_colors.bmp");

    return 0;
}

FIRE(fired_main)
@

We assume that the source dimensions range from 0 to 1 and that the 
color channels in the RGBVec do the same. Randomly generating vectors is then
trivial.

@='generate random demonstrations'
unsigned int seed = std::chrono::system_clock::now().time_since_epoch().count();
std::default_random_engine generator (seed);
std::uniform_real_distribution<Scalar> random(0, 1);
while(n-- > 0)
{
    auto v = Vec2{random(generator), random(generator)};
    auto c = RGBVec{random(generator), random(generator), random(generator)};
    Demo d{n, v, c};
    demos.push_back(d);
}
@

Drawing the image is also quite simple; simply iterate over the dimensions of
the image and query the interpolator at each coordinate. We record how long
this takes so that the program also serves as a simplistic benchmark.

@='draw the image'
for (unsigned int xpix = 0; xpix < x; ++xpix)
{
    for (unsigned int ypix = 0; ypix < y; ++ypix)
    {
        auto q = Vec2{xpix/(Scalar)x, ypix/(Scalar)y};
        auto out = interpolator.query(q, demos) * (Scalar)255;
        img.set_pixel(xpix, ypix,
                (unsigned char)std::round(out.x()),
                (unsigned char)std::round(out.y()),
                (unsigned char)std::round(out.z())); 
    }
}
@

After drawing the overall image, we also take a moment to draw a circle around
each demonstration point; this helps to better understand how the image relates
to the topology of the interpolator.

@='draw circles over demonstrated points'
image_drawer draw(img);
draw.pen_width(1);
for (const auto& demo : demos)
{
    const Vec2& v = demo.s;
    const RGBVec& c = demo.p;
    draw.pen_color(0,0,0);
    draw.pen_width(1);
    draw.circle(v.x() * x, v.y() * y, 7);
    draw.pen_color(255,255,255);
    draw.circle(v.x() * x, v.y() * y, 5);
    draw.pen_color(c.x() * 255, c.y() * 255, c.z() * 255);
    draw.pen_width(3);
    draw.circle(v.x() * x, v.y() * y, 2);
}
@

## WebGL Interactive Example

This example offers some insight into the inner workings of the interpolator.
A handful of demonstrations associating random 2D positions with random colors
are generated. The position and color of each point is visualized by drawing a
dot of the appropriate color at that position. In addition, a circle is drawn
around each dot with the radius associated to that demonstration by the
interpolator. Finally, a grey region is drawn beneath each dot whose size
reflects the contribution of that dot to the weighted sum. 

The query point is based on the position of the cursor within the screen. Its
color is based on the result of the interpolation. A radial circle is also
drawn for this point.

The bulk of this happens in the display callback. For some reason, it appears
to be necessary to draw in depth order (back to front) so that the dots and
radial lines dont become obscured by the weight disk in the back. If anyone
can explain why this is, please contact me. The z-coordinate doesn't appear to
have any influence, even with depth testing enabled.

@='display callback'
void drawCircle(const Vec2& position, const Scalar& radius, const Scalar& depth = 0)
{
    constexpr Scalar pi = 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899863;
    for (float w = 0; w <= 2 * pi; w += 0.1)
    {
        glVertex3f(
                position.x() + std::cos(w) * radius, 
                position.y() + std::sin(w) * radius,
                depth);
    }
}

void drawCircleFilled(const Vec2& position, const Scalar& radius, const Scalar& depth = 0)
{
    glBegin(GL_POLYGON);
    drawCircle(position, radius, depth);
    glEnd();
}

void drawCircleWire(const Vec2& position, const Scalar& radius, const Scalar& depth = 0)
{
    glBegin(GL_LINE_LOOP);
    drawCircle(position, radius, depth);
    glEnd();
}

void display()
{
    constexpr float dot_radius = 0.01;
    auto q_color = interpolator.query(q, demos);

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    for (const auto& d : demos)
    {
        const auto& v = d.s;
        // draw disk for weight
        glColor4f(0.2, 0.2, 0.2, 0.1);
        drawCircleFilled(v, d.w/3, -1);
    }

    for (const auto& d : demos)
    {
        const auto& v = d.s;
        const auto& c = d.p;
        // draw radial circle
        glColor3f(c.x(), c.y(), c.z());
        drawCircleWire(v, d.r, 1);
    }

    for (const auto& d : demos)
    {
        const auto& v = d.s;
        const auto& c = d.p;
        // draw colored dots
        glColor3f(c.x(), c.y(), c.z());
        drawCircleFilled(v, dot_radius, 1);
    }

    glColor3f(q_color.x(), q_color.y(), q_color.z());
    drawCircleWire(q, interpolator.q_radius);
    drawCircleFilled(q, dot_radius, 1);

    glutSwapBuffers();
}
@

All of the points in the scene in world coordinates are in the square region
([0 - 1], [0 - 1]). The reshape callback appropriately sets the viewport and
projection matrices to ensure this region is visible and undistorted. In case
the window is wider than it is tall, padding is added on the sides so that the
scene is centered. Otherwise, when the window is taller than it is wide, the
padding is added above and below the scene.

@='reshape callback'
void reshape(int w, int h)
{
    glViewport(0,0,w,h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (h < w)
    {   // the window is a wide rectangle
        @{h < w: calculate pixels_per_unit and offset}
        glOrtho(-offset, 1 + offset, 0,       1, -1, 1);
    }
    else
    {   // the window is a tall rectangle (or square)
        @{w <= h: calculate pixels_per_unit and offset}
        glOrtho(0,       1,          -offset, 1 + offset, -1, 1);
    }
}
@

@='h < w: calculate pixels_per_unit and offset'
Scalar padding = (w - h)/2; // there is `padding` space on either size of the scene square
Scalar pixels_per_unit = h; // this many pixels per unit in world coordinates
Scalar units_per_pixel = 1/pixels_per_unit;
Scalar offset = padding * units_per_pixel;
@

@='w <= h: calculate pixels_per_unit and offset'
Scalar padding = (h - w)/2; // there is `padding` space above and below the scene square
Scalar pixels_per_unit = w; // this many pixels per unit in world coordinates
Scalar units_per_pixel = 1/pixels_per_unit;
Scalar offset = padding * units_per_pixel;
@

The position of the query vector `q` is updated in the mouse move callback.
This requires a similar calculation as the reshape callback, only going the
other direction.

This callback also drives updates to the display, since moving the cursor
will change the state of the interpolator.

@='motion callback'
void mouse_move(int x, int y)
{
    y = glutGet(GLUT_WINDOW_HEIGHT) - y; // flip y so it goes from the bottom left
    int w = glutGet(GLUT_WINDOW_WIDTH);
    int h = glutGet(GLUT_WINDOW_HEIGHT);
    if (h < w)
    {   // the window is a wide rectangle
        @{h < w: calculate pixels_per_unit and offset}
        q.x() = (Scalar)x / pixels_per_unit - offset;
        q.y() = (Scalar)y / pixels_per_unit;
    }
    else
    {   // the window is a tall rectangle (or square)
        @{w <= h: calculate pixels_per_unit and offset}
        q.x() = (Scalar)x / pixels_per_unit;
        q.y() = (Scalar)y / pixels_per_unit - offset;
    }
    glutPostRedisplay();
}
@

The rest of the program is basically boilerplate for setting up openGL.

@='setup display and callbacks'
// fake argv and argc since we can't access the real ones behind fire-hpp
char * fake_argv[1];
std::string prog_name = "interactive_colors";
fake_argv[0] = &*prog_name.begin();
int fake_argc = 1;

glutInit(&fake_argc, fake_argv);
glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);
glutInitWindowPosition(0,0);
glutInitWindowSize(500,500);
glutCreateWindow("Interactive Interpolator Demo");
glutMotionFunc(mouse_move);
glutPassiveMotionFunc(mouse_move);
glutDisplayFunc(display);
glutReshapeFunc(reshape);
glEnable(GL_DEPTH_TEST);
glClearColor(0,0,0,0);
glClear(GL_COLOR_BUFFER_BIT);
glutSwapBuffers();
@

@#'examples/interactive_colors.cpp'
#include <string>
#include <cmath>
#include <chrono>
#include <random>
#include <iostream>
#include <GL/gl.h>
#include <GL/glut.h>
#include <Eigen/Core>
#include "include/fire-hpp/fire.hpp"
#include "../interpolator/marier_spheres.h"

@{basic globals}
Vec2 q = {0,0};

@{display callback}

@{reshape callback}

@{motion callback}

int fired_main(unsigned int n = fire::arg("n", "The number of demonstrations", 5))
{
    @{generate random demonstrations}

    @{setup display and callbacks}

    glutMainLoop();

    return 0;
}

FIRE(fired_main)
@
