<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>marier_spheres</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" type="text/css" href="http://traviswest.ca/style.css">
</head>
<body>
<h1 id="background">Background</h1>
<p>In sound design, digital musical instrument design, and intermedia art in general, creators often deal with complex generative systems with numerous control parameters: sound and video synthesizers and processors, simulations, and artificially intelligent agents are a few examples. These systems are often capable of producing a combinatorially immense variety of interesting behaviors (sounds, images, etc.) based on the state of their parameters. Much of the creative work of using and interacting with these systems comes down to exploring these vast spaces of possibilities, perhaps noting points of interest along the way. Eventually, entire compositions, installations, or musical instruments can be devised by selecting the paths to navigate within these spaces of possibilities.</p>
<p>A useful tool in the exploration and navigation of these spaces is preset interpolation. After manually recording points of interest in parameter space as presets, preset interpolation algorithms are used to automatically move between these predetermined a-priori interesting places, filling in the space between them with intermediate locations that are likely, by proximity, to also be interesting. This allows the user of a preset interpolation algorithm to move easily through the space of possibilities demarcated by the points of interest they record as presets, facilitating the discovery of other interesting points in space and of interesting paths through space.</p>
<p>What is especially useful about preset interpolation is that it allows the user to reframe the navigation of the control parameter space in terms of another separate space of control sources. For instance, the presets in parameter space can be associated with locations on a two dimensional map, often significantly reducing the dimensionality of navigation with an associated reduction in the difficulty of navigation. Alternatively, the control sources from a complex gestural interface can be used instead of a two dimensional map, allowing the destination space to be navigated by moving through the space of gestures afforded by the interface. These kinds of mappings are often essential in the design of digital musical instruments, and can be equally rewarding in other intermedia artistic practices.</p>
<p>The basic operating principle of many preset interpolation algorithms, including the one presented here, is for the user to specify pairs of source-to-destination associations in the form of presets in these two spaces. As a concrete example, the user might be exploring the space of sounds produced by a synthesizer with possibly a very large number of parameters. They might explore for a while by manually configuring the synthesizer, and note several particularly interesting preset sound configurations. Then, to facilitate live performance with the synthesizer, the user may wish to control it with a graphics tablet. They can associate several locations on the tablet with different presets found earlier, and then use the preset interpolation algorithm to navigate between these presets. The tablet locations can also be thought of as presets in the source space rather than the destination space of the sound synthesizer.</p>
<p>To remain unambiguous, for the rest of this exposition preset points in source space will be refered to as source vectors while preset points in destination space will be referred to as destination vectors. The word vector reflects the assumption inherent in most preset interpolation algorithms that the source and destination spaces are both vector spaces, meaning that presets can be meaningfully scaled and added together, and that there is a meaningful notion of distance between presets. A pair made of a source vector <span class="math inline">\(s\)</span> and a destination vector <span class="math inline">\(p\)</span> to which the sources in the vicinity of <span class="math inline">\(s\)</span> should be associated will be called a demonstration. This reflects an interaction metaphor in which the user is thought to provide demonstrations of action-to-output relationships, i.e. “when I do <span class="math inline">\(s\)</span>, the interpolator should output <span class="math inline">\(p\)</span>.”</p>
<p>The basic principle of many interpolation algorithms is to interpolate between destination vectors producing an output parameter vector <span class="math inline">\(y\)</span> via a weighted sum.</p>
<p><span class="math display">\[
y(\boldsymbol{w}) = \sum_{i = 0}^{n - 1} w_i * p_i
\]</span></p>
<p>Where <span class="math inline">\(n\)</span> is the number of demonstrations (i.e. the size of the set <span class="math inline">\(D\)</span> of demonstrations). The role of the preset interpolator is then reduced to simply producing and applying a list of weights, usually as a function of a query or cursor vector <span class="math inline">\(q\)</span> in the source space, and the list of demonstrations.</p>
<p><span class="math display">\[
\boldsymbol{w}(q, D) = {w_0, w_1, w_2, ..., w_{n}} 
\]</span> <span class="math display">\[
D = { {s_0, p_0}, {s_1, p_1}, {s_2, p_2}, ..., {s_n, p_n} }
\]</span></p>
<h1 id="intersecting-n-spheres-interpolation">Intersecting N-Spheres Interpolation</h1>
<p>Martin Marier introduced the <em>intersecting n-spheres interpolation</em> algorithm as part of his work with The Sponge, a deformable digital musical instrument which Marier has been developing for over a decade. This algorithm produces an interpolated output that is smooth (i.e. continuously differentiable), continuous, maps from any number of source dimensions to any number of destination dimensions, exactly passes through the demonstrated destination points, and locally depends only on nearby demonstrations. The algorithm also imposes no constraints on the placement of source and destination presets, unlike other algorithms which might require points to be evenly distributed or quantized to a grid. Furthermore, the algorithm allows for the position of presets to be dynamically varied in real-time, allowing the possibility for higher-level mappings such as navigating destination presets for the preset interpolation system itself using a higher-level preset interpolator.</p>
<p>Intersecting n-spheres interpolation produces weights for a weighted sum according to the following procedure:</p>
<ol type="1">
<li><p>For every point in source space including the cursor point, determine the distance (<span class="math inline">\(R\)</span> for the cursor point, <span class="math inline">\(r_i\)</span> for the demonstrated source points) from that point to its nearest neighbour in source space. Consider the distances <span class="math inline">\(R\)</span> and <span class="math inline">\(r_i\)</span> as the radii of circles centered on their respective points.</p></li>
<li><p>Determine the distance <span class="math inline">\(d_i\)</span> from each demonstrated source point <span class="math inline">\(s_i\)</span> to the cursor point.</p></li>
<li><p>The weight <span class="math inline">\(w_i\)</span> associated with the destination vector <span class="math inline">\(p_i\)</span> of the <span class="math inline">\(i\)</span>th demonstration is given by the <span class="math inline">\(A_x(R, r_i, d_i) / A(r_i)\)</span> where <span class="math inline">\(A_x\)</span> is the area of the intersection of the circles defined by <span class="math inline">\(R\)</span>, <span class="math inline">\(r_i\)</span>, and their respective data points as though the circles lay on a plane passing through both points, and <span class="math inline">\(A\)</span> is the area of the circle defined by <span class="math inline">\(r_i\)</span> and its point. <span class="math inline">\(A_x\)</span> is given by the following function, which depends only on the radii of the two circles and the distance between them:</p></li>
</ol>
<p><span class="math display">\[
\begin{aligned}
A_x(R, r, d) &amp;= r^2 cos^(-1) ( \frac{d^2 + r^2 - R^2}{2dr} ) \\
             &amp;+ R^2 cos^(-1) ( \frac{d^2 + R^2 - r^2}{2dR} ) \\
             &amp;- \frac{\sqrt{(-d + r + R)(d + r - R)(d - r + R)(d + r + R)}}{2}
\end{aligned}
\]</span></p>
<ol start="4" type="1">
<li>Normalize the weights so that their sum is equal to one.</li>
</ol>
<p>The algorithm, despite its name, actually doesn’t utilized hyperspheres. Intead, 2D areas are used, simplifying the algorithm while producing results that “are predictable and feel natural to the user” according to Marier.</p>
<h1 id="implementation">Implementation</h1>
<p>The weighted sum in Marier’s algorithm implies that the destination space is some kind of vector space, while the requirement for a notion of distance implies that the source space is a normed vector space, most often an Euclidean vector space. These assumptions are represented in the implementation by the assumption that the templated PVector for the destination space will have an operator for multiplication by a scalar, and addition of two vectors, and that the templated SVector for the source space will have the same two operators as well as a method <code>norm</code> that returns the length of a vector.</p>
<p>The functions to compute the weight for a single destination vector are generally straightforward to implement based on the equations in step 3 above.</p>
<p>One necessary quirk: when the interpolator is used with <code>float</code> scalars, the argument to the <code>acos</code> and <code>sqrt</code> calls sometimes falls just outside the domain of the functions. Boundary conditions are checked if <code>Scalar</code> is <code>float</code>: in testing, the <code>acos</code> args only ever fell at or slightly above <code>1.0f</code>, so this is the only condition which is addressed by the boundary check for these args.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">// @=&#39;weight functions&#39;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> Scalar&gt;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>Scalar circle_circle_intersection_area(</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>        <span class="at">const</span> Scalar&amp; R, </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>        <span class="at">const</span> Scalar&amp; r, </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        <span class="at">const</span> Scalar&amp; d)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>{</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>    Scalar d2 = d * d;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>    Scalar r2 = r * r;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>    Scalar R2 = R * R;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>    Scalar two_d = (Scalar)<span class="dv">2</span> * d;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>    Scalar arg1 = (d2 + r2 - R2)/(two_d * r);</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>    Scalar arg2 = (d2 + R2 - r2)/(two_d * R);</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>    Scalar arg3 = (-d+r+ R) * (d+r-R) * (d-r+R) * (d+r+R);</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>    Scalar a, b, c;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> (<span class="bu">std::</span>is_same_v&lt;Scalar, <span class="dt">float</span>&gt;)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>    {</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>        <span class="cf">if</span> (arg1 &gt; <span class="fl">1.0</span><span class="bu">f</span>) a = <span class="dv">0</span>;</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>        <span class="cf">else</span> a = r2 * <span class="bu">std::</span>acos(arg1);</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>        <span class="cf">if</span> (arg2 &gt; <span class="fl">1.0</span><span class="bu">f</span>) b = <span class="dv">0</span>;</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>        <span class="cf">else</span> b = R2 * <span class="bu">std::</span>acos(arg2);</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>        <span class="cf">if</span> (arg3 &lt; <span class="fl">0.0</span><span class="bu">f</span>) c = <span class="dv">0</span>;</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>        <span class="cf">else</span> c = <span class="bu">std::</span>sqrt(arg3) / <span class="fl">2.0</span><span class="bu">f</span>;</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>    }</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a>    <span class="cf">else</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a>    {</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>        a = r2 * <span class="bu">std::</span>acos(arg1);</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a>        b = R2 * <span class="bu">std::</span>acos(arg2);</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a>        c = <span class="bu">std::</span>sqrt(arg3) / (Scalar)<span class="fl">2.0</span>;</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a>    }</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a>    <span class="cf">return</span> a + b - c;</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a>}</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> Scalar&gt;</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true"></a>Scalar circle_area(<span class="at">const</span> Scalar&amp; r)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true"></a>{</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true"></a>    <span class="kw">constexpr</span> Scalar pi = <span class="fl">3.14159265358979323846264338327950288419716939937510582097494459230781640628620899863</span>;</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true"></a>    <span class="cf">return</span> pi * r * r;</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true"></a>}</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> Scalar&gt;</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true"></a>Scalar marier_spheres_weight(<span class="at">const</span> Scalar&amp; R, <span class="at">const</span> Scalar&amp; r, <span class="at">const</span> Scalar&amp; d)</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true"></a>{</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true"></a>    <span class="cf">return</span> circle_circle_intersection_area(R, r, d) / circle_area(r);</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true"></a>}</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<p>Step 1 above is an instance of the “all nearest neighbours” problem. We are given a set of points (the demonstrated points in the source space plus the cursor point) and for each point <span class="math inline">\(p\)</span> we need to determine the nearest other point in the space <span class="math inline">\(p_{\text{nearest}}\)</span>, which will be used to determine the radius of the circle associated with <span class="math inline">\(p\)</span>.</p>
<p>Efficient algorithms exist which solve the all nearest neighbours problem in <span class="math inline">\(O(n\log n)\)</span> time, or even in <span class="math inline">\(O(n)\)</span> time if certain constraints are met, which is most likely the case for this application. Unfortunately, comprehending (let alone implementing) the linear time algorithms for this problem is non-trivial, so we opt to use a simpler algorithm until such time as it becomes clear that optimization is necessary.</p>
<p>Updating any of the points in source space including the cursor point always requires the nearest neighbour problem to be solved anew, because the nearest neighbour of the updated point and any point that it was previously the nearest neighbour of all have to be updated. Because the position of the cursor point is assumed to change whenever the interpolator is queried, this means that the nearest neighbour problem must be solved for every query. The trivial implementation used here (as well as in Marier’s original presentation of the interpolation algorithm) solves this problem with <span class="math inline">\(O(n^2)\)</span> time complexity. In Marier’s practice this hasn’t been reported as an issue, presumably because the number of data points has always been reasonably low.</p>
<p>Because the all nearest neighbours problem has to be solved for every query, there is no need for a special data structure to hold the demonstrations. The query function could be written as a generic pure function over the query point and the list of demonstrations. However, for interactive applications it is likely to be useful for the caller to query the radii and weights associated with each demonstration, so room for these is included in the data structure for holding a demonstration.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">// @=&#39;intersecting n-spheres&#39;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> Scalar, <span class="kw">typename</span> ID, <span class="kw">typename</span> SVector, <span class="kw">typename</span> PVector&gt;</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">class</span> MarierSpheresInterpolator</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>{</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    <span class="kw">struct</span> Demo { ID id; SVector s; PVector p; Scalar r, d, w;};</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>    Scalar q_radius;</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>    <span class="kw">template</span>&lt;<span class="kw">typename</span> DemoList&gt;</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>    PVector query(<span class="at">const</span> SVector&amp; q, DemoList&amp; demos)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>    {</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>        Scalar sum_of_weights = <span class="dv">0</span>;</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>        PVector weighted_sum = PVector() * <span class="dv">0</span>;</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>        <span class="cf">if</span> (demos.size() &lt; <span class="dv">1</span>) <span class="cf">return</span> weighted_sum;</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>        <span class="er">@</span>{find q_radius}</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="kw">auto</span>&amp; demo : demos)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>        {</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a>            <span class="er">@</span>{calculate distance}</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a>        </span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a>            <span class="er">@</span>{find radius}</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a>        </span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a>            <span class="cf">if</span> ((q_radius + demo.r) &lt; demo.d) </span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a>            {</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a>                demo.w = <span class="dv">0</span>;</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true"></a>                <span class="cf">continue</span>; <span class="co">// the circles are non-intersecting</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true"></a>            }</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true"></a>            demo.w = marier_spheres_weight(q_radius, demo.r, demo.d);</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true"></a>            sum_of_weights = sum_of_weights + demo.w;</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true"></a>            weighted_sum = weighted_sum + demo.w * demo.p;</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true"></a>        }</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true"></a>        weighted_sum = (<span class="dv">1</span> / sum_of_weights) * weighted_sum;</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="kw">auto</span>&amp; demo : demos) { demo.w = demo.w / sum_of_weights; }</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true"></a>        <span class="cf">return</span> weighted_sum;</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true"></a>    }</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true"></a>};</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<p>The radius associated with the query point (and indeed every point) is searched for by brute force. Although far from optimal, this implementation seems good enough for now.</p>
<p>Although every demonstration will be visited in the main loop of the query function, the radius of the query point has to be known in advance in order to calculate the weight associated with each point.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">// @=&#39;find q_radius&#39;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>q_radius = <span class="bu">std::</span>numeric_limits&lt;Scalar&gt;::max();</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span>&amp; demo : demos)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>{</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    Scalar d = (demo.s - q).norm();</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>    <span class="cf">if</span> (d &lt; q_radius) q_radius = d;</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>}</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<p>If the query is close enough to the demonstration, the exact value of the demonstration is returned and further calculation of the weighted sum is short-circuited. As the query point approaches the position of a demonstrated point, the size of both <span class="math inline">\(A_x\)</span> and <span class="math inline">\(A\)</span> get smaller and smaller, which would likely lead to numerical instability when calculating the weight <span class="math inline">\(A_x/A\)</span>. For this reason, an arbitrary amount of sloppiness is introduced into the determination of whether the query point exactly coincides with a demonstrated point, so that the ratio <span class="math inline">\(A_x/A\)</span> will not be calculated if the query is too close to a demonstration.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">// @=&#39;calculate distance&#39;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>demo.d = (demo.s - q).norm();</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="kw">constexpr</span> Scalar an_arbitrary_slop_factor = </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    <span class="bu">std::</span>numeric_limits&lt;Scalar&gt;::epsilon() * <span class="dv">5</span>;</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="cf">if</span> (demo.d &lt;= an_arbitrary_slop_factor) <span class="cf">return</span> demo.p;</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">// @=&#39;find radius&#39;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>demo.r = <span class="bu">std::</span>numeric_limits&lt;Scalar&gt;::max();</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span>&amp; demo2 : demos)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>{</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span class="cf">if</span> (demo.id == demo2.id) <span class="cf">continue</span>;</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    Scalar d = (demo.s - demo2.s).norm();</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    <span class="cf">if</span> (d &lt; demo.r) demo.r = d;</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>}</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a><span class="cf">if</span> (demo.d &lt; demo.r) demo.r = demo.d;</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<p>Putting it all together, we get a reasonably generic header-only library implementing Marier’s algorithm.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">// @#&#39;interpolator/marier_spheres.h&#39;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="pp">#ifndef MARIER_SPHERES_INTERPOLATOR_H</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="pp">#define MARIER_SPHERES_INTERPOLATOR_H</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;limits&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a><span class="er">@</span>{weight functions}</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a><span class="er">@</span>{intersecting n-spheres}</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a><span class="pp">#endif</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<h1 id="usage">Usage</h1>
<p>The remainder of this document elaborates some example programs demonstrating the usage of the library. The drawing example renders an image based on interpolating randomly generated colors associated with randomly generated 2D positions. The interactive example works similarly, only instead of systematically querying the image the user moves a cursor around it to query the interpolated colors, and the graphics are updated in real time to reflect the underlying state of the interpolator.</p>
<h2 id="drawing-example">Drawing example</h2>
<p>This simple command line drawing application will randomly generate a handful of source-destination demonstrations, and draw an image by systematically querying the source space. As well as producing an image that might offer some intuition about the topology of the interpolated output, this will also serve as a reasonable benchmark for the efficiency of the implementation if the number of pixels in the image is large enough. The initial implementation of the interpolator, when compiled with optimizations enabled, could process about 15000 queries per second with 5 demonstrations, about 5000 per second with 15 demonstrations, 2200 with 25 demonstrations, and 1200 with 35 demonstrations. As per the quadratic time complexity of this implementation, the number of queries processed per second decreases by a multiplicative factor as the number of demonstrations increases linearly.</p>
<p>Here’s the overview of the example source code:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">// @=&#39;basic globals&#39;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="kw">using</span> Scalar = <span class="dt">float</span>;</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="kw">using</span> ID = <span class="dt">unsigned</span> <span class="dt">int</span>;</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="kw">using</span> Vec2 = Eigen::Vector2f;</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="kw">using</span> RGBVec = Eigen::Vector3f;</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="kw">using</span> Interpolator = MarierSpheresInterpolator&lt;Scalar, ID, Vec2, RGBVec&gt;;</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="kw">using</span> Demo = <span class="kw">typename</span> Interpolator::Demo;</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>Interpolator interpolator;</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;Demo&gt; demos;</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">// @#&#39;examples/color_image.cpp&#39;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;random&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;chrono&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;include/fire-hpp/fire.hpp&quot;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;include/bitmap/bitmap_image.hpp&quot;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;../interpolator/marier_spheres.h&quot;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;Eigen/Core&gt;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a><span class="er">@</span>{basic globals}</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a><span class="dt">int</span> fired_main(</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>        <span class="dt">unsigned</span> <span class="dt">int</span> x = fire::arg(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;The horizontal dimension in pixels&quot;</span>, <span class="dv">500</span>), </span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a>        <span class="dt">unsigned</span> <span class="dt">int</span> y = fire::arg(<span class="st">&quot;y&quot;</span>, <span class="st">&quot;The vertical dimension in pixels&quot;</span>, <span class="dv">500</span>), </span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a>        <span class="dt">unsigned</span> <span class="dt">int</span> n = fire::arg(<span class="st">&quot;n&quot;</span>, <span class="st">&quot;The number of demonstrations&quot;</span>, <span class="dv">5</span>))</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>{</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a>    bitmap_image img(x, y); </span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a>    img.clear();</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a>    <span class="er">@</span>{generate random demonstrations}</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true"></a>    <span class="kw">auto</span> start = <span class="bu">std::</span>chrono<span class="bu">::</span>high_resolution_clock<span class="bu">::</span>now();</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true"></a>    <span class="er">@</span>{draw the image}</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true"></a></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true"></a>    <span class="kw">auto</span> stop = <span class="bu">std::</span>chrono<span class="bu">::</span>high_resolution_clock<span class="bu">::</span>now();</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true"></a>    <span class="kw">auto</span> usec = <span class="bu">std::</span>chrono<span class="bu">::</span>duration_cast&lt;<span class="bu">std::</span>chrono<span class="bu">::</span>microseconds&gt;(stop - start).count();</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Generated &quot;</span> &lt;&lt; x * y &lt;&lt; <span class="st">&quot; interpolations in &quot;</span> &lt;&lt; usec &lt;&lt; <span class="st">&quot; microseconds</span><span class="sc">\n</span><span class="st">&quot;</span> </span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true"></a>            &lt;&lt; <span class="st">&quot;About &quot;</span> &lt;&lt; <span class="dv">1000000</span> * x * y / usec &lt;&lt; <span class="st">&quot; interpolations per second&quot;</span> </span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true"></a>            &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true"></a></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true"></a>    <span class="er">@</span>{draw circles over demonstrated points}</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true"></a></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true"></a>    img.save_image(<span class="st">&quot;interpolated_colors.bmp&quot;</span>);</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true"></a></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true"></a>}</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true"></a></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true"></a>FIRE(fired_main)</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<p>We assume that the source dimensions range from 0 to 1 and that the color channels in the RGBVec do the same. Randomly generating vectors is then trivial.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">// @=&#39;generate random demonstrations&#39;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="dt">unsigned</span> <span class="dt">int</span> seed = <span class="bu">std::</span>chrono<span class="bu">::</span>system_clock<span class="bu">::</span>now().time_since_epoch().count();</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="bu">std::</span>default_random_engine generator (seed);</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="bu">std::</span>uniform_real_distribution&lt;Scalar&gt; random(<span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a><span class="cf">while</span>(n-- &gt; <span class="dv">0</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>{</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    <span class="kw">auto</span> v = Vec2{random(generator), random(generator)};</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>    <span class="kw">auto</span> c = RGBVec{random(generator), random(generator), random(generator)};</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>    Demo d{n, v, c};</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>    demos.push_back(d);</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>}</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<p>Drawing the image is also quite simple; simply iterate over the dimensions of the image and query the interpolator at each coordinate. We record how long this takes so that the program also serves as a simplistic benchmark.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co">// @=&#39;draw the image&#39;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="cf">for</span> (<span class="dt">unsigned</span> <span class="dt">int</span> xpix = <span class="dv">0</span>; xpix &lt; x; ++xpix)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>{</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">unsigned</span> <span class="dt">int</span> ypix = <span class="dv">0</span>; ypix &lt; y; ++ypix)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    {</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>        <span class="kw">auto</span> q = Vec2{xpix/(Scalar)x, ypix/(Scalar)y};</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>        <span class="kw">auto</span> out = interpolator.query(q, demos);</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>        img.set_pixel(xpix, ypix,</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>                (<span class="dt">unsigned</span> <span class="dt">char</span>)<span class="bu">std::</span>round(out.x() * <span class="dv">255</span>),</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>                (<span class="dt">unsigned</span> <span class="dt">char</span>)<span class="bu">std::</span>round(out.y() * <span class="dv">255</span>),</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>                (<span class="dt">unsigned</span> <span class="dt">char</span>)<span class="bu">std::</span>round(out.z() * <span class="dv">255</span>)); </span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>    }</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>}</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<p>After drawing the overall image, we also take a moment to draw a circle around each demonstration point; this helps to better understand how the image relates to the topology of the interpolator.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">// @=&#39;draw circles over demonstrated points&#39;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>image_drawer draw(img);</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>draw.pen_width(<span class="dv">1</span>);</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span>&amp; demo : demos)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>{</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>    <span class="at">const</span> Vec2&amp; v = demo.s;</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>    <span class="at">const</span> RGBVec&amp; c = demo.p;</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>    draw.pen_color(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>);</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>    draw.pen_width(<span class="dv">1</span>);</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>    draw.circle(v.x() * x, v.y() * y, <span class="dv">7</span>);</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>    draw.pen_color(<span class="dv">255</span>,<span class="dv">255</span>,<span class="dv">255</span>);</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>    draw.circle(v.x() * x, v.y() * y, <span class="dv">5</span>);</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>    draw.pen_color(c.x() * <span class="dv">255</span>, c.y() * <span class="dv">255</span>, c.z() * <span class="dv">255</span>);</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>    draw.pen_width(<span class="dv">3</span>);</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>    draw.circle(v.x() * x, v.y() * y, <span class="dv">2</span>);</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>}</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<h2 id="opengl-interactive-example">OpenGL Interactive Example</h2>
<p>This example offers some insight into the inner workings of the interpolator. A handful of demonstrations associating random 2D positions with random colors are generated. The position and color of each point is visualized by drawing a dot of the appropriate color at that position. In addition, a circle is drawn around each dot with the radius associated to that demonstration by the interpolator; notice how each demonstrated point’s radial circle always intersects at least one other dot, which is the nearest neighbour of that demonstrated point. Finally, a grey region is drawn beneath each dot whose size and brightness reflect the contribution of that dot to the weighted sum.</p>
<p>The position of the query point is based on the position of the cursor within the screen. Its color is based on the result of the interpolation. A radial circle is also drawn for this point.</p>
<p>The bulk of this happens in the display callback. For some reason, it appears to be necessary to draw in depth order (back to front) so that the dots and radial lines dont become obscured by the weight disk in the back. If anyone can explain why this is, please contact me. The z-coordinate doesn’t appear to have any influence, even with depth testing enabled.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">// @=&#39;display callback&#39;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="dt">void</span> drawCircle(<span class="at">const</span> Vec2&amp; position, <span class="at">const</span> Scalar&amp; radius, <span class="at">const</span> Scalar&amp; depth = <span class="dv">0</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>{</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>    <span class="kw">constexpr</span> Scalar pi = <span class="fl">3.14159265358979323846264338327950288419716939937510582097494459230781640628620899863</span>;</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">float</span> w = <span class="dv">0</span>; w &lt;= <span class="dv">2</span> * pi; w += <span class="fl">0.1</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>    {</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>        glVertex3f(</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>                position.x() + <span class="bu">std::</span>cos(w) * radius, </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>                position.y() + <span class="bu">std::</span>sin(w) * radius,</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>                depth);</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>    }</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>}</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a><span class="dt">void</span> drawCircleFilled(<span class="at">const</span> Vec2&amp; position, <span class="at">const</span> Scalar&amp; radius, <span class="at">const</span> Scalar&amp; depth = <span class="dv">0</span>)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a>{</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a>    glBegin(GL_POLYGON);</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a>    drawCircle(position, radius, depth);</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a>    glEnd();</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a>}</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true"></a></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true"></a><span class="dt">void</span> drawCircleWire(<span class="at">const</span> Vec2&amp; position, <span class="at">const</span> Scalar&amp; radius, <span class="at">const</span> Scalar&amp; depth = <span class="dv">0</span>)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true"></a>{</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true"></a>    glBegin(GL_LINE_LOOP);</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true"></a>    drawCircle(position, radius, depth);</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true"></a>    glEnd();</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true"></a>}</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true"></a></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true"></a><span class="dt">void</span> display()</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true"></a>{</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true"></a>    <span class="kw">constexpr</span> <span class="dt">float</span> dot_radius = <span class="fl">0.01</span>;</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true"></a>    <span class="kw">auto</span> q_color = interpolator.query(q, demos);</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true"></a></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true"></a>    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true"></a></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span>&amp; d : demos)</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true"></a>    {</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true"></a>        <span class="at">const</span> <span class="kw">auto</span>&amp; v = d.s;</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true"></a>        <span class="co">// draw disk for weight</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true"></a>        glColor4f(d.w, d.w, d.w, d.w);</span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true"></a>        drawCircleFilled(v, d.w/<span class="dv">3</span>, -<span class="dv">1</span>);</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true"></a>    }</span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true"></a></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span>&amp; d : demos)</span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true"></a>    {</span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true"></a>        <span class="at">const</span> <span class="kw">auto</span>&amp; v = d.s;</span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true"></a>        <span class="at">const</span> <span class="kw">auto</span>&amp; c = d.p;</span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true"></a>        <span class="co">// draw radial circle</span></span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true"></a>        glColor3f(c.x(), c.y(), c.z());</span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true"></a>        drawCircleWire(v, d.r, <span class="dv">1</span>);</span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true"></a>        drawCircleWire(v, d.r - <span class="fl">0.001</span>, <span class="dv">1</span>);</span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true"></a>    }</span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true"></a></span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span>&amp; d : demos)</span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true"></a>    {</span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true"></a>        <span class="at">const</span> <span class="kw">auto</span>&amp; v = d.s;</span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true"></a>        <span class="at">const</span> <span class="kw">auto</span>&amp; c = d.p;</span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true"></a>        <span class="co">// draw colored dots</span></span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true"></a>        glColor3f(c.x(), c.y(), c.z());</span>
<span id="cb12-59"><a href="#cb12-59" aria-hidden="true"></a>        drawCircleFilled(v, dot_radius, <span class="dv">1</span>);</span>
<span id="cb12-60"><a href="#cb12-60" aria-hidden="true"></a>    }</span>
<span id="cb12-61"><a href="#cb12-61" aria-hidden="true"></a></span>
<span id="cb12-62"><a href="#cb12-62" aria-hidden="true"></a>    glColor3f(q_color.x(), q_color.y(), q_color.z());</span>
<span id="cb12-63"><a href="#cb12-63" aria-hidden="true"></a>    drawCircleWire(q, interpolator.q_radius);</span>
<span id="cb12-64"><a href="#cb12-64" aria-hidden="true"></a>    drawCircleWire(q, interpolator.q_radius - <span class="fl">0.001</span>);</span>
<span id="cb12-65"><a href="#cb12-65" aria-hidden="true"></a>    drawCircleFilled(q, dot_radius, <span class="dv">1</span>);</span>
<span id="cb12-66"><a href="#cb12-66" aria-hidden="true"></a></span>
<span id="cb12-67"><a href="#cb12-67" aria-hidden="true"></a>    glutSwapBuffers();</span>
<span id="cb12-68"><a href="#cb12-68" aria-hidden="true"></a>}</span>
<span id="cb12-69"><a href="#cb12-69" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<p>All of the points in the scene in world coordinates are in the square region ([0 - 1], [0 - 1]). The reshape callback appropriately sets the viewport and projection matrices to ensure this region is visible and undistorted. In case the window is wider than it is tall, padding is added on the sides so that the scene is centered. Otherwise, when the window is taller than it is wide, the padding is added above and below the scene.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="co">// @=&#39;reshape callback&#39;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="dt">void</span> reshape(<span class="dt">int</span> w, <span class="dt">int</span> h)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>{</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    glViewport(<span class="dv">0</span>,<span class="dv">0</span>,w,h);</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>    glMatrixMode(GL_PROJECTION);</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>    glLoadIdentity();</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>    <span class="cf">if</span> (h &lt; w)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>    {   <span class="co">// the window is a wide rectangle</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>        <span class="er">@</span>{h &lt; w: calculate pixels_per_unit <span class="kw">and</span> offset}</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>        glOrtho(-offset, <span class="dv">1</span> + offset, <span class="dv">0</span>,       <span class="dv">1</span>, -<span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>    }</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>    <span class="cf">else</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>    {   <span class="co">// the window is a tall rectangle (or square)</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>        <span class="er">@</span>{w &lt;= h: calculate pixels_per_unit <span class="kw">and</span> offset}</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a>        glOrtho(<span class="dv">0</span>,       <span class="dv">1</span>,          -offset, <span class="dv">1</span> + offset, -<span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a>    }</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a>}</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">// @=&#39;h &lt; w: calculate pixels_per_unit and offset&#39;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>Scalar padding = (w - h)/<span class="dv">2</span>; <span class="co">// there is `padding` space on either size of the scene square</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>Scalar pixels_per_unit = h; <span class="co">// this many pixels per unit in world coordinates</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>Scalar units_per_pixel = <span class="dv">1</span>/pixels_per_unit;</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>Scalar offset = padding * units_per_pixel;</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="co">// @=&#39;w &lt;= h: calculate pixels_per_unit and offset&#39;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>Scalar padding = (h - w)/<span class="dv">2</span>; <span class="co">// there is `padding` space above and below the scene square</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>Scalar pixels_per_unit = w; <span class="co">// this many pixels per unit in world coordinates</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>Scalar units_per_pixel = <span class="dv">1</span>/pixels_per_unit;</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>Scalar offset = padding * units_per_pixel;</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<p>The position of the query vector <code>q</code> is updated in the mouse move callback. This requires a similar calculation as the reshape callback, only going the other direction.</p>
<p>This callback also drives updates to the display, since moving the cursor will change the state of the interpolator.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="co">// @=&#39;motion callback&#39;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="dt">void</span> mouse_move(<span class="dt">int</span> x, <span class="dt">int</span> y)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>{</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>    y = glutGet(GLUT_WINDOW_HEIGHT) - y; <span class="co">// flip y so it goes from the bottom left</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    <span class="dt">int</span> w = glutGet(GLUT_WINDOW_WIDTH);</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>    <span class="dt">int</span> h = glutGet(GLUT_WINDOW_HEIGHT);</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>    <span class="cf">if</span> (h &lt; w)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>    {   <span class="co">// the window is a wide rectangle</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>        <span class="er">@</span>{h &lt; w: calculate pixels_per_unit <span class="kw">and</span> offset}</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>        q.x() = (Scalar)x / pixels_per_unit - offset;</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a>        q.y() = (Scalar)y / pixels_per_unit;</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a>    }</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a>    <span class="cf">else</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a>    {   <span class="co">// the window is a tall rectangle (or square)</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a>        <span class="er">@</span>{w &lt;= h: calculate pixels_per_unit <span class="kw">and</span> offset}</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a>        q.x() = (Scalar)x / pixels_per_unit;</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true"></a>        q.y() = (Scalar)y / pixels_per_unit - offset;</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true"></a>    }</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true"></a>    glutPostRedisplay();</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true"></a>}</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<p>The rest of the program is basically boilerplate for setting up openGL.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="co">// @=&#39;setup display and callbacks&#39;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="co">// fake argv and argc since we can&#39;t access the real ones behind fire-hpp</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a><span class="dt">char</span> * fake_argv[<span class="dv">1</span>];</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a><span class="bu">std::</span>string prog_name = <span class="st">&quot;interactive_colors&quot;</span>;</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>fake_argv[<span class="dv">0</span>] = &amp;*prog_name.begin();</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a><span class="dt">int</span> fake_argc = <span class="dv">1</span>;</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>glutInit(&amp;fake_argc, fake_argv);</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>glutInitWindowPosition(<span class="dv">0</span>,<span class="dv">0</span>);</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a>glutInitWindowSize(<span class="dv">500</span>,<span class="dv">500</span>);</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a>glutCreateWindow(<span class="st">&quot;Interactive Interpolator Demo&quot;</span>);</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a>glutMotionFunc(mouse_move);</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true"></a>glutPassiveMotionFunc(mouse_move);</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true"></a>glutDisplayFunc(display);</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true"></a>glutReshapeFunc(reshape);</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true"></a>glEnable(GL_DEPTH_TEST);</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true"></a>glClearColor(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>);</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true"></a>glClear(GL_COLOR_BUFFER_BIT);</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true"></a>glutSwapBuffers();</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="co">// @#&#39;examples/interactive_colors.cpp&#39;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;chrono&gt;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;random&gt;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;GL/gl.h&gt;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;GL/glut.h&gt;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;Eigen/Core&gt;</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;include/fire-hpp/fire.hpp&quot;</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;../interpolator/marier_spheres.h&quot;</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a><span class="er">@</span>{basic globals}</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a>Vec2 q = {<span class="dv">0</span>,<span class="dv">0</span>};</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true"></a></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true"></a><span class="er">@</span>{display callback}</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true"></a><span class="er">@</span>{reshape callback}</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true"></a></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true"></a><span class="er">@</span>{motion callback}</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true"></a></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true"></a><span class="dt">int</span> fired_main(<span class="dt">unsigned</span> <span class="dt">int</span> n = fire::arg(<span class="st">&quot;n&quot;</span>, <span class="st">&quot;The number of demonstrations&quot;</span>, <span class="dv">5</span>))</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true"></a>{</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true"></a>    <span class="er">@</span>{generate random demonstrations}</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true"></a></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true"></a>    <span class="er">@</span>{setup display <span class="kw">and</span> callbacks}</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true"></a></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true"></a>    glutMainLoop();</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true"></a></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true"></a>}</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true"></a></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true"></a>FIRE(fired_main)</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true"></a><span class="co">// @</span></span></code></pre></div>
<h2 id="compiling-examples">Compiling Examples</h2>
<p>Both examples are relatively simple with just a few dependencies. Both rely on Eigen, and the interactive example additionally requires OpenGL. Make sure that these libraries are installed on your system. The other dependencies (fire-hpp and bitmap) are both included as subtrees in this repository, so you should not have to do anything to install them.</p>
<p>The image example can be compiled with this command:</p>
<p><code>g++ -std=c++17 -I/usr/include/eigen3/ -O3 examples/color_image.cpp</code></p>
<p>The interactive example can be compiled with this command:</p>
<p><code>g++ -std=c++17 -I/usr/include/eigen3/ -lGL -lglut -O3 examples/interactive_colors.cpp</code></p>
<p>In both cases, you may need to update the path to Eigen based on the particularities of your system. The above commands, possibly with slight modifications, should work on most Linux distributions and MacOS.</p>
<p>If you are a Windows user, it should be relatively straightforward to adapt the above commands to use Windows development tools. Please let me know how it goes and I would be happy to include more detailed instructions here.</p>
</body>
</html>
